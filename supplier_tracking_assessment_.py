# -*- coding: utf-8 -*-
"""Supplier Tracking Assessment .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v6BD3Ixun7mLaXBs0A0KQkBdLziJkOew
"""

!pip install streamlit openai requests pandas
import requests
import pandas as pd
import openai
from datetime import datetime
from google.colab import files

# --- CONFIGURACIÓN ---
mediastack_key = "36e342f19ea0d1bae2e7e85478d43491"
gnews_key = "fced21e37c55c04a7f927c1ee3d995f1"
gpt_api_key = "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"

# --- FUNCIONES DE EXTRACCIÓN DE NOTICIAS ---

def obtener_noticias_gnews(query):
    url = f"https://gnews.io/api/v4/search?q={query}&lang=es&token={gnews_key}&max=10"
    noticias = []
    response = requests.get(url)
    if response.status_code == 200:
        datos = response.json()
        for articulo in datos.get('articles', []):
            noticias.append({
                "titulo": articulo.get('title', ''),
                "url": articulo.get('url', ''),
                "contenido": articulo.get('content', ''),
            })
    else:
        print(f"Error GNews: {response.status_code}")
    return pd.DataFrame(noticias)

def obtener_noticias_mediastack(query):
    url = f"http://api.mediastack.com/v1/news?access_key={mediastack_key}&languages=es&keywords={query}&limit=10"
    noticias = []
    response = requests.get(url)
    if response.status_code == 200:
        datos = response.json()
        for articulo in datos.get('data', []):
            noticias.append({
                "titulo": articulo.get('title', ''),
                "url": articulo.get('url', ''),
                "contenido": articulo.get('description', ''),
            })
    else:
        print(f"Error Mediastack: {response.status_code}")
    return pd.DataFrame(noticias)

# --- FUNCIONES GPT ---
openai.api_key = gpt_api_key

def obtener_intro_gpt(proveedor):
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Eres un asistente experto en investigación empresarial."},
                {"role": "user", "content": f"Proporciona una breve introducción sobre la empresa {proveedor}."}
            ]
        )
        return response['choices'][0]['message']['content'].strip()
    except Exception as e:
        return f"Error: {str(e)}"

def clasificar_riesgo_gpt(texto):
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Eres un experto en riesgos corporativos."},
                {"role": "user", "content": f"Clasifica el siguiente texto en una categoría de riesgo: financiero, legal, operativo, reputacional, cadena de suministro. Texto: {texto}"}
            ]
        )
        return response['choices'][0]['message']['content'].strip()
    except Exception as e:
        return f"Error: {str(e)}"

# --- FUNCIÓN PRINCIPAL ---
def analizar_proveedor(proveedor):
    # Obtener introducción del proveedor
    intro = obtener_intro_gpt(proveedor)
    print("\nIntroducción sobre el proveedor:")
    print(intro)

    # Obtener noticias de GNews
    noticias_gnews = obtener_noticias_gnews(proveedor)

    # Obtener noticias de Mediastack
    noticias_mediastack = obtener_noticias_mediastack(proveedor)

    # Combinar resultados
    resultados = pd.concat([noticias_gnews, noticias_mediastack]).drop_duplicates().reset_index(drop=True)

    # Validar si hay resultados
    if resultados.empty:
        print("\nNo se encontraron noticias. Verifica el nombre del proveedor o las claves API.")
    else:
        # Análisis de clasificación de riesgos
        resultados['riesgo'] = resultados['contenido'].fillna('').apply(lambda x: clasificar_riesgo_gpt(x[:500]))
        tabla_resultados = resultados[['titulo', 'url', 'riesgo']]
        print("\nResultados del análisis:")
        print(tabla_resultados)

        # --- EXPORTAR RESULTADOS ---
        fecha_actual = datetime.now().strftime('%Y%m%d_%H%M%S')
        archivo_csv = f"analisis_riesgos_{fecha_actual}.csv"
        tabla_resultados.to_csv(archivo_csv, index=False, encoding='utf-8-sig')
        files.download(archivo_csv)

# --- EJECUCIÓN ---
proveedor = input("Introduce el nombre del proveedor a buscar: ")
analizar_proveedor(proveedor)

